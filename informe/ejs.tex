\section{Ejercicios}

\subsection{Ejercicio 1}
En \'este ejercicio debemos programar una tarea \textit{TaskConsola} la cual debe realizar n llamadas bloqueantes, cada una con una duraci\'on al azar entre bmin y bmax, ambas pasadas por par\'ametro.\\

Para ello, decidimos utilizar un contador de 0 hasta n y generar un n\'umero pseudo-alaeatorio por medio de la funci\'on \textit{rand}.\\
Es decir, cada vez que se aumenta el contador, realizamos una llamada bloqueante (uso\_IO) que durar\'a la cantidad de ciclos que se haya generado en la llamada a rand.

\subsection{Ejercicio 2}
Para \'este experimento proponemos el siguiente lote de tareas:

\begin{center}
TaskCPU 10\\
TaskConsola 5 1 5\\
TaskConsola 3 1 2
\end{center}

En la primera, utlizaremos TaskCPU y para darle uso intensivo correr\'a durante 10 ciclos de reloj.\\
Las siguientes, son de tipo TaskConsola implementado anteriormente, pas\'andole como par\'ametro el n\'umero de llamadas bloqueantes y el rango en el cual debe seleccionar el n\'umero aleatorio.

En el algoritmo FCFS (First Came, First Served), la CPU se asigna a los procesos en el orden en que la solicitan.\\
Por lo tanto, en nuestras simulaciones deben aparecer de forma tal que con un solo n\'ucleo un proceso no pueda correr hasta que no terminaron los anteriores a el.
En el caso de dos, correr\'an dos procesos simlt\'aneamente y la \'ultima empezar\'a cuando alguna de las otras dos finalicen, y por \'ultimo, si el procesador tiene 3 n\'ucleos los 3 correr\'an al mismo tiempo.

\vspace{\baselineskip}
\begin{center}
\includegraphics[scale=0.45]{../tp1/Test/resEj2Co1.png}
\\
\vspace{1pt}
\footnotesize\textit{Simulacro FCFS con un n\'ucleo}
\end{center}
\vspace{\baselineskip}


\vspace{\baselineskip}
\begin{center}
\includegraphics[scale=0.45]{../tp1/Test/resEj2Co2.png}
\\
\vspace{1pt}
\footnotesize\textit{Simulacro FCFS con dos n\'ucleos}
\end{center}
\vspace{\baselineskip}

\vspace{\baselineskip}
\begin{center}
\includegraphics[scale=0.45]{../tp1/Test/resEj2Co3.png}
\\
\vspace{1pt}
\footnotesize\textit{Simulacro FCFS con tres n\'ucleos}
\end{center}
\vspace{\baselineskip}


Como podemos observar, los experimentos resultaron satisfactoriamente con nuestra hip\'otesis.\\
Adem\'as, notemos que en los casos en los que utilizamos la tarea TaskConsola, se observan claramente las llamadas bloqueantes de manera random, dado que el tiempo tanto de la ejecuci\'on como el de las llamadas bloqueantes var\'ia.
En el caso en que el procesador tiene tres n\'ucleos, se observa que los n\'ucleos 2 y 0 ejecutan Idle ya que est\'an desocupadas, esperando la solicitud del pr\'oximo proceso.

\subsection{Ejercicio 3}
La idea del scheduler \textit{Round-Robin} es darle un quantum a cada procesador, cuando un proceso lo solicita, si alg\'un n\'ucleo esta desocupado, corre la tarea el tiempo que sea el quantum del procesador seleccionado.\\
Con esta idea desarrollamos nuestro Scheduler Round-Robin.\\
Utilizamos como estructura una Cola $(q)$, para las llamadas a los procesos, 
un vector $(quantum)$ de tama\~no cantidad de cores del procesador que asignar\'a el quantum del i\'esimo n\'ucleo, 
y otro vector $(contador)$ que va a llevar cuenta del tiempo corrido por el proceso en el i\'esimo n\'ucleo hasta llegar al quantum del mismo.

Para el correcto funcionamiento en la funci\'on $tick$ se ven reflejados los casos en el cual el proceso debe dejar de correr ya sea porque termin\'o su tiempo o el quantum del procesador en el que corr\'ia. En \'este \'ultimo caso, la posici\'on correspondiente al n\'ucleo en $contador$ volver\'a a cero y el proceso se encolar\'a para terminar con su tiempo. 
\\Una vez realizada dicha acci\'on, debe dar lugar a la siguiente en la cola, o en caso de no haber una la Idle deber\'a hacerlo hasta el llamado de una nueva.
\subsection{Ejercicio 4}
\subsection{Ejercicio 5}
\subsection{Ejercicio 6}
\subsection{Ejercicio 7}
\subsection{Ejercicio 8}
\subsection{Ejercicio 9}
\subsection{Ejercicio 10}